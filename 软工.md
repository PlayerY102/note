# 软工

## 类图

* 类图是软件的蓝图，用于详细描述系统内各个对象的相关的类，以及这些类之间的静态关系

  * 类组件：类名，属性，方法
  * 类间关系：六种关系
  * 关系要素:名称、多重性表达式、导航符号、角色名称

* 设计类是已经完成了规格说明并且达到能够被实现程度的类

* 在分析中，只要尽量捕获系统需要的行为，而完全不必考虑如何去实现这些行为

* 在设计中，则必须准确地说明类是如何履行它们的职责
  * 完整的属性集合，包括详细说明的名称、类型、可视性和一些默认值
  * 将分析类指定的职责转化成一个或多个操作的完整集合

* 类图-类组件

  * 类名：类名 如果是抽象类需要用斜体字表示
  * 类属性：可见性 名称： 类型[=缺省值]
  * +(public) -(private) #(protected) ~(package)
  * 类方法 可见性 名称(参数列表) [: 返回类型]
* 类图-类间关系
  * 依赖关系
  * 关联关系
  * 聚合关系
  * 组合关系
  * 泛化关系
  * 实现关系(类与接口)

  * 耦合度由低到高 好的设计目标是最小化类间耦合度

  * 关联关系-单向关联
    * 一个类知道另一个类的属性或方法
    * 有箭头代表对方能访问到该类，可以理解为消息发送的方向
  * 关联关系-双向关联
    * 两个类互相知道对方的属性和方法。尽量使用单向关联，降低耦合度
    * 无箭头版更为常用
  * 关联关系-多元关联
    * 多个类之间互相关联/一个类与多个类关联
  * 关联关系-聚集
    * 表示整体-部分的关联。整体包含部分，但是部分可以脱离整体单独存在。耦合度较弱
  * 关联关系-组合
    * 同样表示整体-部分的关联。整体包含部分，部分不能脱离整体单独存在。耦合度较强
  * 关联关系-关联类
    * 关联类即是类也是关联。他有着关联和类的特性。他将多个类连接起来同时又具有属性和操作。
    * 面对对象的编程语言不支持关联类的实现
    * 设计时需要将关联类直接定义为普通的类，从而将一个多对多的关系转变为两个一对多的关系

* 类图-类间关系-依赖关系
  * 某个类以成员变量的形式出现在另一个类中，二者时关联关系；某个类似局部变量的形式出现在另一个类中，二者是依赖关系。
  * 依赖关系是临时性的使用关系
  * 关联关系是“机构化”的关系，依赖关系是“非结构化”的，短暂的关系。
  * 利用对象间的引用（即对象间互相了解的程度）来曲风
    * 属性引用：B对象作为A对象的某个属性（关联关系）
    * 参数引用：B对象作为A对象某个操作的参数（依赖关系）
    * 局部声明引用：B对象作为A对象某个操作内部临时构造的对象（依赖关系）
    * 全局引用：B对象是一个全局对象（依赖关系）

  * 类图-类间关系-泛化关系
    * 泛化关系是类的一般描述和具体描述之间的关系，具体描述建立在一般描述的基础之上，并对其进行了扩展。
  * 类图-类间关系-实现关系
    * 实现关系将一种模型元素（如类）与另一种模型元素（如接口）连接起来。通常情况下，后者是行为的规约，前者要求必须支持至少后者所有操作。
  * 类图-类间关系-多重性

## 状态图

* 由状态机扩展而来，用来描述对象对外部对象响应的历史状态序列，即描述对象所有可能的状态，以及哪些事件将导致状态的改变。
  * 目标是关注内部哪些事件导致状态改变
  * 在类设计期间，针对那些受状态影响的对象进行状态建模
* 组成元素：状态、事件、转换、活动、动作
* 有一个初态和一或多个终态

* 状态图-状态
  * 在对象的生命周期中满足某些条件，执行某些活动或等待某些事件时的一个条件或状态
  * 组成元素：名称、进入/退出动作、内部转换、子状态、延迟事件

* 状态图-转换
  * 两个状态之间的一种关系，表示对象在源状态中执行一定的动作，并在某个特定事件发生二千某个特定的警界条件满足时进入目标的状态。

* 状态图-转换-事件
  * 对触发状态转换的事件的描述
  * 状态和事件不能混淆
  * 不是所有事件都会引起状态转移。
  * 事件触发
    1. 信号事件：实时系统运行中，对象接受到一个系统外界的信号，从而使对象的状态发生迁移的事件
    2. 变化事件： 对象的内部或外部条件发生变化而引起对象状态发生变化的事件
    3. 调用事件：对象的状态在绝对时间上或某个时间段内自动发生迁移
    4. 时间时间：系统之外的其他系统通过接口或某种协议，直接执行该系统内部的对象行为，从而引发对象状态的迁移
* 状态图-并发
  * 分支同时进行，都会被执行
* 状态图-分支与合并
  * 使用分支与合并表示条件选择
* 状态图-其他-组合状态
  * 嵌套在另外一个状态中的状态称之为子状态，一个含有子状态的状态被称作组合状态
* 状态图-其它-进入节点
  * 某些节点由于一些原因并不会执行初始化，而是直接通过一个节点进入状态，则此节点称之为进入节点
* 状态图-其它-历史状态
* 状态图-其它-复合状态
  * 含有一组子状态的状态

## 顺序图

* 顺序图-概述
  * 顺序图描述了一组对象的交互方式，它表示完成某项行为的对象和这些对象之间传递消息的时间顺序
  * 组成元素：参与者，对象，生命线，控制焦点，消息
  * 用例图时系统外部对象(参与者)与系统这两大对象之间的互动，而类图是对系统中涉及到的所有对象，进行抽象描述。顺序图是参与者和系统进行交互，系统内部对象之间的具体互动实现。所以顺序图关联了类图和用例图，可以通过用例图和类图进行整合。
* 顺序图-参与者
  * 参与者是类中的用户类。参与者应该是脱离系统之外的一个单纯的角色。类中定义的属性和操作可以不考虑
  * 系统角色，可以是人、机器、其它系统、子系统
* 顺序图-对象
  * 系统内部参与用例的一群对象
  * 三类：边界类、控制类、实体类。依次按照从左至右的顺序排列。控制类只有一个，边界类和实体类可以由多个。
  * 实体类保存要放进持久存储体的信息。持久存储体就是数据库、文件等可以永久存储数据的介质。实体类可以通过事件流和交互图发现。通常每个实体类在数据库中有相应的表，实体类中的属性对应数据库表中的字段
  * 对象的三种命名方式
    * 对象名和类名 对象:类
    * 类名 :类
    * 对象名 对象
  * 顺序图-生命线
    * 从对象图标向下的一条虚线，表示对象存在的时间
  * 顺序图-控制焦点
    * 表示时间段的符号，在这个时间段内对象将执行相应的操作
  * 顺序图-消息
    * 消息一般分为同步消息、异步消息和返回消息。
    * 消息的发送者吧控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义。
    * 消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接收者返回消息或者控制。异步消息的接收者和发送者是并发工作的。
    * 返回消息表示从过程调用返回。
    * 自关联消息表示的自身调用以及一个对象内的一个方法调用另一个方法。